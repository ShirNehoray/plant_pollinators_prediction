---
title: "Species Similarity Between Bioregions"
output: html_document
date: "2025-09-21"
---
```{r}
library(dplyr)
library(ggplot2)
library(colorspace)
library(bipartite)  
library(tidyr)
library(readr)
library(vegan)

setwd("/Users/shirn/Documents/Master/data")
#setwd("/Users/shirnehoray/EDA/plant_pollinators_prediction/EDA_Eupoll")


# Read the data
data <- read.csv("Interaction_data.csv", encoding = "latin1")

networks_per_bioregion <- data %>%
  filter(!is.na(Bioregion) & Bioregion != "") %>% # Clean up any missing or empty bioregion names
  select(Bioregion, Network_id) %>%
  distinct() %>%  # Get unique pairs of Bioregion/Network_id
  group_by(Bioregion) %>%
  summarise(network_count = n()) %>% # Count the number of unique networks for each bioregion
  ungroup() %>%
  mutate(Bioregion_sorted = reorder(Bioregion, network_count))

# Plot
ggplot(networks_per_bioregion, aes(x = Bioregion_sorted, y = network_count)) +
  geom_col(aes(fill = Bioregion_sorted), show.legend = FALSE) + 
  coord_flip() + 
  labs(
    title = "Number of Plant-Pollinator Networks per Bioregion",
    x = "Bioregion", 
    y = "Number of Networks" 
  ) +
  geom_text(aes(label = network_count), hjust = -0.2, size = 3) +
  theme_minimal(base_size = 12) + 
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"), 
    plot.margin = margin(10, 30, 10, 10),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()  
  ) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) 


```
```{r}
# Plotting for network with Apidea interactions 

networks_with_apidae <- data %>%
  filter(Pollinator_family == "Apidae") %>%
  select(Bioregion, Network_id) %>%
  distinct()

# Networks per bioregions
apidae_networks_per_bioregion <- networks_with_apidae %>%
  filter(!is.na(Bioregion) & Bioregion != "") %>% # Clean up any missing or empty bioregion names
  group_by(Bioregion) %>%
  summarise(network_count_apidae = n()) %>% # Count the number of unique networks
  ungroup() %>%
  mutate(Bioregion_sorted_apidae = reorder(Bioregion, network_count_apidae))

# Plot
ggplot(apidae_networks_per_bioregion, aes(x = Bioregion_sorted_apidae, y = network_count_apidae)) +
  geom_col(aes(fill = Bioregion_sorted_apidae), show.legend = FALSE) + # Create the bars
  coord_flip() + 
  labs(
    title = "Number of Networks with Apidae Pollinators Interaction per Bioregion",
    x = "Bioregion",
    y = "Number of Networks (with Apidae Interactions)"
  ) +
  geom_text(aes(label = network_count_apidae), hjust = -0.2, size = 3) +
  theme_minimal(base_size = 12) + 
  theme(
    plot.title = element_text(hjust = 0.5, size = 11, face = "bold"), 
    plot.margin = margin(10, 30, 10, 10), 
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank()  
  ) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) 

```

```{r}

# Get unique species lists for each network
species_per_network <- data %>%
  group_by(Bioregion, Network_id) %>%
  summarise(
    Plants = list(unique(Plant_accepted_name)),
    Pollinators = list(unique(Pollinator_accepted_name)),
    .groups = "drop"
  )

# Function to calculate Jaccard similarity
jaccard_similarity <- function(set1, set2) {
  inter <- length(intersect(set1, set2))
  union <- length(union(set1, set2))
  if (union == 0) return(NA) else return(inter / union)
}

# Loop over each bioregion and create heatmap for each one
bioregions <- unique(species_per_network$Bioregion)
```

```{r}
# For plants species 

for (bio in bioregions) {
  cat("Plotting Bioregion:", bio, "\n")
  
  sub_data <- species_per_network %>% filter(Bioregion == bio)
  nets <- sub_data$Network_id
  
  # Build similarity matrix
  mat <- matrix(NA, nrow = length(nets), ncol = length(nets),
                dimnames = list(nets, nets))
  for (i in seq_along(nets)) {
    for (j in seq_along(nets)) {
      mat[i,j] <- jaccard_similarity(sub_data$Plants[[i]], sub_data$Plants[[j]])
    }
  }
  
  # Turn into data frame 
  mat_df <- as.data.frame(as.table(mat))
  
  # Plot heatmap
  p <- ggplot(mat_df, aes(Var1, Var2, fill = Freq)) +
    geom_tile()  +
    scale_fill_continuous_sequential(palette = "Viridis",) +
    theme_minimal() +
    labs(title = paste("Plant species similarity -", bio),
         x = "Network_id", y = "Network_id", fill = "Jaccard Index") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 3),
          axis.text.y = element_text(size = 3))
  
  
  print(p)
}

```

```{r}
# For pollinators species 

for (bio in bioregions) {
  cat("Plotting Bioregion:", bio, "\n")
  
  sub_data <- species_per_network %>% filter(Bioregion == bio)
  nets <- sub_data$Network_id
  
  # Build similarity matrix
  mat <- matrix(NA, nrow = length(nets), ncol = length(nets),
                dimnames = list(nets, nets))
  for (i in seq_along(nets)) {
    for (j in seq_along(nets)) {
      mat[i,j] <- jaccard_similarity(sub_data$Pollinators[[i]], sub_data$Pollinators[[j]])
    }
  }
  
  # Turn into data frame
  mat_df <- as.data.frame(as.table(mat))
  
  # Plot heatmap
  p <- ggplot(mat_df, aes(Var1, Var2, fill = Freq)) +
    geom_tile() +
    scale_fill_continuous_sequential(palette = "Viridis") +
    theme_minimal() +
    labs(title = paste("Pollinators species similarity -", bio),
         x = "Network_id", y = "Network_id", fill = "Jaccard Index") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 3),
          axis.text.y = element_text(size = 3))
  
  
  print(p)
}

```





```{r}
bioregions <- c("Atlantic", "Boreal", "Continental", "Alpine", "Mediterranean", "Steppic", "Pannonian")
min_total <- 15     # minimum total species per network
top_n_pairs <- 100   # how many top pairs to keep (optional)


## =========Utilities===========

normalize_name <- function(x) {
  # Optional: standardize species names (trim, collapse spaces, lower-case)
  x <- trimws(x)
  x <- gsub("\\s+", " ", x)
  tolower(x)
}

jaccard_sets <- function(a, b) {
  a <- unique(a); b <- unique(b)
  ia <- length(intersect(a, b))
  ua <- length(union(a, b))
  if (ua == 0) NA_real_ else ia / ua
}

## ========= Loop for each bioregions===========

for (bio in bioregions) {
  cat(sprintf("\n=== Processing Bioregion: %s ===\n", bio))

  ## ======== Set Columns ==========

  req_cols <- c("Bioregion", "Network_id", "Plant_accepted_name", "Pollinator_accepted_name")
  missing_cols <- setdiff(req_cols, names(data))
  if (length(missing_cols) > 0) {
    cat(paste("Missing required columns:", paste(missing_cols, collapse = ", "), "\n"))
    next
  }

  ## ========= Set the chosen bioregion ========

  dat_bio <- data[data$Bioregion == bio, , drop = FALSE]

  if (nrow(dat_bio) == 0) {
    cat(paste("No rows for Bioregion:", bio, "\n"))
    next
  }

  ## ===== species counts per network (to filter small networks) ====
  
  # Distinct plants per network
  plants_by_net <- aggregate(Plant_accepted_name ~ Network_id, data = dat_bio,
                             FUN = function(x) length(unique(x)))
  names(plants_by_net)[2] <- "n_plants"

  # Distinct pollinators per network
  polls_by_net <- aggregate(Pollinator_accepted_name ~ Network_id, data = dat_bio,
                            FUN = function(x) length(unique(x)))
  names(polls_by_net)[2] <- "n_pollinators"

  # Merge counts and compute total
  counts <- merge(plants_by_net, polls_by_net, by = "Network_id", all = TRUE)
  counts$n_plants[is.na(counts$n_plants)] <- 0
  counts$n_pollinators[is.na(counts$n_pollinators)] <- 0
  counts$total_species <- counts$n_plants + counts$n_pollinators

  # Keep networks meeting the threshold
  nets_keep <- counts$Network_id[counts$total_species >= min_total]
  if (length(nets_keep) == 0) {
    cat(paste("No networks with total_species >=", min_total, "in", bio, "\n"))
    next
  }

  ## ====== Build species sets per network (plants + pollinators together) =====
  # Subset to kept networks
  dat_bio_sub <- dat_bio[dat_bio$Network_id %in% nets_keep, , drop = FALSE]

  # Normalize names (optional but recommended)
  plant_names <- normalize_name(dat_bio_sub$Plant_accepted_name)
  poll_names  <- normalize_name(dat_bio_sub$Pollinator_accepted_name)

  # Tag guilds to avoid accidental collisions
  plant_tags <- paste0("PLANT::", plant_names)
  poll_tags  <- paste0("POLL::",  poll_names)

  # Split row indices by Network_id so we can collect species per network
  idx_by_net <- split(seq_len(nrow(dat_bio_sub)), dat_bio_sub$Network_id)

  # For each network, take the union of unique plant & pollinator tags
  species_items <- lapply(idx_by_net, function(idx) {
    unique(c(plant_tags[idx], poll_tags[idx]))
  })
  # 'species_items' is a named list: names(species_items) are Network_id values

  net_ids <- names(species_items)
  n <- length(net_ids)

  ## ======== Pairwise Jaccard matrix =====
  cat(sprintf("Number of networks for %s: %d\n", bio, n)) # Diagnostic
  sim_mat <- matrix(NA_real_, nrow = n, ncol = n, dimnames = list(net_ids, net_ids))

  for (i in seq_len(n)) {
    # diagonal
    sim_mat[i, i] <- NA_real_
    # upper triangle only
    if (i < n) {
      for (j in (i + 1L):n) {
        val <- jaccard_sets(species_items[[i]], species_items[[j]])
        sim_mat[i, j] <- val
        sim_mat[j, i] <- val
      }
    }
  }

  ## ===== Tidy table of unique pairs =====
  # Convert matrix to data.frame of pairs
  # keep only i<j to avoid duplicates
  pairs_list <- list()
  k <- 0L
  for (i in seq_len(n)) {
    if (i < n) {
      for (j in (i + 1L):n) {
        k <- k + 1L
        pairs_list[[k]] <- data.frame(
          Net1 = net_ids[i],
          Net2 = net_ids[j],
          Jaccard = sim_mat[i, j],
          stringsAsFactors = FALSE
        )
      }
    }
  }
  sim_df <- do.call(rbind, pairs_list)
  if (is.null(sim_df) || nrow(sim_df) == 0 || !("Jaccard" %in% names(sim_df)) || all(is.na(sim_df$Jaccard))) {
    cat(sprintf("No valid Jaccard similarities for %s (empty or all NA).\n", bio))
    next
  }

  # Remove NA and sort descending
  sim_df <- sim_df[!is.na(sim_df$Jaccard), , drop = FALSE]
  ord <- order(sim_df$Jaccard, decreasing = TRUE)
  sim_df <- sim_df[ord, , drop = FALSE]

  # Keep top N pairs (optional)
  if (!is.null(top_n_pairs) && is.finite(top_n_pairs)) {
    top_n <- min(top_n_pairs, nrow(sim_df))
    sim_top <- sim_df[seq_len(top_n), , drop = FALSE]
  } else {
    sim_top <- sim_df
  }

  ## ======Results =======
  cat(sprintf("\n=== Top similar network pairs for %s ===\n", bio))
  print(head(sim_top, 20), row.names = FALSE)

  ## ======= Heatmap of Jaccard similarities ======
  # Convert sim_mat to long format for ggplot
  sim_mat_long <- as.data.frame.table(sim_mat, responseName = "Jaccard")
  names(sim_mat_long)[1:2] <- c("Net1", "Net2")
  sim_mat_long <- sim_mat_long[!is.na(sim_mat_long$Jaccard), ]

  # # Create heatmap
  # p_heatmap <- ggplot(sim_mat_long, aes(x = Net1, y = Net2, fill = Jaccard)) +
  #   geom_tile() +
  #   scale_fill_continuous_sequential(palette = "Viridis", name = "Jaccard Similarity") +
  #   labs(
  #     title = sprintf("Jaccard Similarity Heatmap for %s", bio),
  #     x = "Network ID", y = "Network ID"
  #   ) +
  #   theme_minimal() +
  #   theme(
  #     axis.text.x = element_text(angle = 75, hjust = 1, size = 3),
  #     axis.text.y = element_text(size = 3),
  #     panel.grid = element_blank()
  #   )
  # 
  # print(p_heatmap)



  ## ===== Collect per-network coordinates for the networks in top pairs ========
  # unique networks from the top pairs
  unique_nets <- unique(c(sim_top$Net1, sim_top$Net2))

  # subset interactions to the chosen bioregion and those networks
  dat_map <- dat_bio_sub[dat_bio_sub$Network_id %in% unique_nets, , drop = FALSE]

  if (!all(c("Latitude","Longitude") %in% names(dat_map))) {
    cat("Latitude/Longitude columns are missing in the dataset.\n")
    next
  }

  # Ensure numeric (safely)
  dat_map$Latitude  <- suppressWarnings(as.numeric(dat_map$Latitude))
  dat_map$Longitude <- suppressWarnings(as.numeric(dat_map$Longitude))

  # remove rows with missing coordinates
  dat_map <- dat_map[!is.na(dat_map$Latitude) & !is.na(dat_map$Longitude), , drop = FALSE]
  if (nrow(dat_map) == 0) {
    cat("No valid coordinates to plot.\n")
    next
  }

  ## For each Network_id, take a single representative lat/lon (first unique non-NA)
  first_unique <- function(x) {
    ux <- unique(x)
    ux[!is.na(ux)][1]
  }

  # get the location for each network 
  
 # aggregate coordinates per network 
  lat_by_net <- aggregate(Latitude  ~ Network_id, data = dat_map, FUN = first_unique)
  lon_by_net <- aggregate(Longitude ~ Network_id, data = dat_map, FUN = first_unique)


  # merge back
  net_locs <- merge(lat_by_net, lon_by_net, by = "Network_id", all = TRUE)

  # add total species to size points (we already computed 'counts' earlier)
  net_locs <- merge(net_locs, counts[, c("Network_id","total_species")], by = "Network_id", all.x = TRUE)

  # keep only networks we actually plot
  net_locs <- net_locs[net_locs$Network_id %in% unique_nets, , drop = FALSE]

  ## ======Determine map extents ========

  lat_range <- range(net_locs$Latitude,  na.rm = TRUE)
  lon_range <- range(net_locs$Longitude, na.rm = TRUE)
  lat_buffer <- 2
  lon_buffer <- 3
  xlim <- c(lon_range[1] - lon_buffer, lon_range[2] + lon_buffer)
  ylim <- c(lat_range[1] - lat_buffer, lat_range[2] + lat_buffer)

  ## ====== Base map (Europe) and plot ============

  europe <- rnaturalearth::ne_countries(scale = "medium", returnclass = "sf", continent = "Europe")

  # simple palette for distinct networks
  n_cols <- length(unique(net_locs$Network_id))
  cols <- grDevices::hcl.colors(n_cols, palette = "Spectral", rev = TRUE)

   p_map <- ggplot(europe) +
    geom_sf(fill = "beige", color = "black", linewidth = 0.2) +
    geom_point(
      data = net_locs,
      aes(x = Longitude, y = Latitude, color = Network_id, size = total_species),
      alpha = 0.8
    ) +
    scale_color_manual(values = cols, guide = "none") +
    scale_size_continuous(range = c(2, 8), name = "Total Species") +
    coord_sf(xlim = xlim, ylim = ylim, expand = FALSE, default_crs = NULL) +
    labs(
      title = sprintf("Top similar networks in %s ", bio),
      subtitle = sprintf("Points sized by total species",
                         lat_range[1], lat_range[2]),
      x = "Longitude", y = "Latitude", color = "Network_id"
    ) +
    theme_minimal() +
    theme(legend.position = "bottom")

  print(p_map)
}

```














