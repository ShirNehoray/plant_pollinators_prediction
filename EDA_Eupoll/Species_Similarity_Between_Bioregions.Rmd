---
title: "Species Similarity Between Bioregions"
output: html_document
date: "2025-09-21"
---
```{r}

# Load needed packages
library(dplyr)
library(ggplot2)
library(colorspace)
library(bipartite)   # for network analysis
library(tidyr)
library(readr)
library(vegan)

setwd("/Users/shirn/OneDrive/Documents/master/data")

# Read the data
data <- read.csv("Interaction_data.csv", encoding = "latin1")

# Get unique species lists for each network
species_per_network <- data %>%
  group_by(Bioregion, Network_id) %>%
  summarise(
    Plants = list(unique(Plant_accepted_name)),
    Pollinators = list(unique(Pollinator_accepted_name)),
    .groups = "drop"
  )

# Function to calculate Jaccard similarity
jaccard_similarity <- function(set1, set2) {
  inter <- length(intersect(set1, set2))
  union <- length(union(set1, set2))
  if (union == 0) return(NA) else return(inter / union)
}

# Loop over each bioregion and create heatmap for each one
bioregions <- unique(species_per_network$Bioregion)
```

```{r}
# For plants species 

for (bio in bioregions) {
  cat("Plotting Bioregion:", bio, "\n")
  
  sub_data <- species_per_network %>% filter(Bioregion == bio)
  nets <- sub_data$Network_id
  
  # Build similarity matrix
  mat <- matrix(NA, nrow = length(nets), ncol = length(nets),
                dimnames = list(nets, nets))
  for (i in seq_along(nets)) {
    for (j in seq_along(nets)) {
      mat[i,j] <- jaccard_similarity(sub_data$Plants[[i]], sub_data$Plants[[j]])
    }
  }
  
  # Turn into data frame 
  mat_df <- as.data.frame(as.table(mat))
  
  # Plot heatmap
  p <- ggplot(mat_df, aes(Var1, Var2, fill = Freq)) +
    geom_tile()  +
    scale_fill_continuous_sequential(palette = "Viridis",) +
    theme_minimal() +
    labs(title = paste("Plant species similarity -", bio),
         x = "Network_id", y = "Network_id", fill = "Jaccard Index") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 3),
          axis.text.y = element_text(size = 3))
  
  
  print(p)
}

```

```{r}
# For pollinators species 

for (bio in bioregions) {
  cat("Plotting Bioregion:", bio, "\n")
  
  sub_data <- species_per_network %>% filter(Bioregion == bio)
  nets <- sub_data$Network_id
  
  # Build similarity matrix
  mat <- matrix(NA, nrow = length(nets), ncol = length(nets),
                dimnames = list(nets, nets))
  for (i in seq_along(nets)) {
    for (j in seq_along(nets)) {
      mat[i,j] <- jaccard_similarity(sub_data$Pollinators[[i]], sub_data$Pollinators[[j]])
    }
  }
  
  # Turn into data frame
  mat_df <- as.data.frame(as.table(mat))
  
  # Plot heatmap
  p <- ggplot(mat_df, aes(Var1, Var2, fill = Freq)) +
    geom_tile() +
    scale_fill_continuous_sequential(palette = "Viridis") +
    theme_minimal() +
    labs(title = paste("Pollinators species similarity -", bio),
         x = "Network_id", y = "Network_id", fill = "Jaccard Index") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 3),
          axis.text.y = element_text(size = 3))
  
  
  print(p)
}

```

```{r}
# # For plants species - Focus on most similar networks per bioregion
# 
# # Loop over each bioregion
# for (bio in bioregions) {
#   cat("Processing Bioregion for Plants:", bio, "\n")
#   
#   sub_data <- species_per_network %>% filter(Bioregion == bio)
#   nets <- sub_data$Network_id
#   
#   # Build similarity matrix
#   mat <- matrix(NA, nrow = length(nets), ncol = length(nets),
#                 dimnames = list(nets, nets))
#   for (i in seq_along(nets)) {
#     for (j in seq_along(nets)) {
#       if (i == j) {
#         mat[i,j] <- NA  # Exclude diagonal
#       } else {
#         mat[i,j] <- jaccard_similarity(sub_data$Plants[[i]], sub_data$Plants[[j]])
#       }
#     }
#   }
#   
#   # Convert to dataframe, filter out NA (including diagonal), and find top 10 pairs
#   mat_df <- as.data.frame(as.table(mat)) %>%
#     filter(!is.na(Freq)) %>%  # Remove NA values (diagonal and any others)
#     arrange(desc(Freq)) %>%
#     slice_head(n = 10)  # Top 10 most similar pairs
#   
#   # Get unique networks involved in top pairs
#   if (nrow(mat_df) > 0) {
#     unique_nets <- unique(c(as.character(mat_df$Var1), as.character(mat_df$Var2)))
#     
#     # Subset the original matrix to these networks
#     sub_mat <- mat[unique_nets, unique_nets]
#     
#     # Convert subset matrix to dataframe for ggplot
#     sub_mat_df <- as.data.frame(as.table(sub_mat))
#     
#     # Plot heatmap for the subset
#     p <- ggplot(sub_mat_df, aes(Var1, Var2, fill = Freq)) +
#       geom_tile(color = "white", size = 0.01) +
#       scale_fill_continuous_sequential(palette = "Viridis", na.value = "grey90") +
#       theme_minimal() +
#       labs(title = paste("Most Networks with Similar Plant Species -", bio),
#            x = "Network_id", y = "Network_id", fill = "Jaccard Index") +
#       theme(axis.text.x = element_text(angle = 80, hjust = 1, size = 6),
#             axis.text.y = element_text(size = 6))
#     
#     print(p)
#   } else {
#     cat("No off-diagonal similarities found in", bio, "\n")
#   }
# }
# 

```

```{r}
# # For pollinator species - Focus on most similar networks per bioregion
# 
# # Loop over each bioregion
# for (bio in bioregions) {
#   cat("Processing Bioregion for Pollinators:", bio, "\n")
#   
#   sub_data <- species_per_network %>% filter(Bioregion == bio)
#   nets <- sub_data$Network_id
#   
#   # Build similarity matrix
#   mat <- matrix(NA, nrow = length(nets), ncol = length(nets),
#                 dimnames = list(nets, nets))
#   for (i in seq_along(nets)) {
#     for (j in seq_along(nets)) {
#       if (i == j) {
#         mat[i,j] <- NA  # Exclude diagonal
#       } else {
#         mat[i,j] <- jaccard_similarity(sub_data$Pollinators[[i]], sub_data$Pollinators[[j]])
#       }
#     }
#   }
#   
#   # Convert to dataframe, filter out NA (including diagonal), and find top 10 pairs
#   mat_df <- as.data.frame(as.table(mat)) %>%
#     filter(!is.na(Freq)) %>%  # Remove NA values (diagonal and any others)
#     arrange(desc(Freq)) %>%
#     slice_head(n = 10)  # Top 10 most similar pairs
#   
#   # Get unique networks involved in top pairs
#   if (nrow(mat_df) > 0) {
#     unique_nets <- unique(c(as.character(mat_df$Var1), as.character(mat_df$Var2)))
#     
#     # Subset the original matrix to these networks
#     sub_mat <- mat[unique_nets, unique_nets]
#     
#     # Convert subset matrix to dataframe for ggplot
#     sub_mat_df <- as.data.frame(as.table(sub_mat))
#     
#     # Plot heatmap for the subset
#     p <- ggplot(sub_mat_df, aes(Var1, Var2, fill = Freq)) +
#       geom_tile(color = "white", size = 0.01) +
#       scale_fill_continuous_sequential(palette = "Viridis", na.value = "grey90") +
#       theme_minimal() +
#       labs(title = paste("Most Networks with Similar Pollinator Species -", bio),
#            x = "Network_id", y = "Network_id", fill = "Jaccard Index") +
#       theme(axis.text.x = element_text(angle = 80, hjust = 1, size = 6),
#             axis.text.y = element_text(size = 6))
#     
#     print(p)
#   } else {
#     cat("No off-diagonal similarities found in", bio, "\n")
#   }
# }
```
```{r}

# Boreal bioregion 
library(scales)

# Get unique species lists for each network
boreal_summary <- data %>%
  filter(Bioregion == "Boreal")

# Count networks by country within the Boreal bioregion
boreal_networks_by_country <- boreal_summary %>%
  select(Network_id, Country) %>%
  distinct() %>%
  count(Country, name = "Num_Networks") %>%
  arrange(desc(Num_Networks))

# Pie chart 
boreal_pie <- ggplot(boreal_networks_by_country, aes(x = "", y = Num_Networks, fill = Country)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y", start = 0) +
  labs(
    title = "Proportion of Boreal Networks by Country",
    fill = "Country"
  ) +
  theme_void() +
  theme(
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
    legend.position = "right",
    legend.title = element_text(size = 11),
    legend.text = element_text(size = 9)
  ) +
  scale_fill_brewer(palette = "Set2")

print(boreal_pie)
```





