---
title: "example"
output: html_document
date: "2025-09-30"
---

```{r}

## ============================
## Parameters
## ============================

setwd("/Users/shirn/OneDrive/Documents/master/data")

library(dplyr)
library(readr)
library(ggplot2)
library(rnaturalearth)
library(rnaturalearthdata)
library(sf) # for coord_sf CRS handling and sf objects
library(tidyr)
library(purrr)
library(colorspace) # for scale_fill_continuous_sequential

bioregions <- c("Atlantic", "Boreal", "Continental", "Alpine", "Mediterranean", "Steppic", "Pannonian")
min_total <- 15     # minimum total species per network
top_n_pairs <- 100   # how many top pairs to keep 

## ============================
## Read data 
## ============================
interactions <- read.csv("Interaction_data.csv", stringsAsFactors = FALSE)

## ============================
## Utilities (base R)
## ============================
normalize_name <- function(x) {
  # Optional: standardize species names (trim, collapse spaces, lower-case)
  x <- trimws(x)
  x <- gsub("\\s+", " ", x)
  tolower(x)
}

jaccard_sets <- function(a, b) {
  a <- unique(a); b <- unique(b)
  ia <- length(intersect(a, b))
  ua <- length(union(a, b))
  if (ua == 0) NA_real_ else ia / ua
}

## ============================
## Loop over bioregions
## ============================
for (bio in bioregions) {
  cat(sprintf("\n=== Processing Bioregion: %s ===\n", bio))

  ## ============================
  ## Column checks
  ## ============================
  req_cols <- c("Bioregion", "Network_id", "Plant_accepted_name", "Pollinator_accepted_name")
  missing_cols <- setdiff(req_cols, names(interactions))
  if (length(missing_cols) > 0) {
    cat(paste("Missing required columns:", paste(missing_cols, collapse = ", "), "\n"))
    next
  }

  ## ============================
  ## 1) Filter to chosen bioregion
  ## ============================
  dat_bio <- interactions[interactions$Bioregion == bio, , drop = FALSE]

  if (nrow(dat_bio) == 0) {
    cat(paste("No rows for Bioregion:", bio, "\n"))
    next
  }

  ## ============================
  ## 2) Compute species counts per network (to filter small networks)
  ##    We need distinct counts of plants & pollinators per Network_id
  ## ============================
  # Distinct plants per network
  plants_by_net <- aggregate(Plant_accepted_name ~ Network_id, data = dat_bio,
                             FUN = function(x) length(unique(x)))
  names(plants_by_net)[2] <- "n_plants"

  # Distinct pollinators per network
  polls_by_net <- aggregate(Pollinator_accepted_name ~ Network_id, data = dat_bio,
                            FUN = function(x) length(unique(x)))
  names(polls_by_net)[2] <- "n_pollinators"

  # Merge counts and compute total
  counts <- merge(plants_by_net, polls_by_net, by = "Network_id", all = TRUE)
  counts$n_plants[is.na(counts$n_plants)] <- 0
  counts$n_pollinators[is.na(counts$n_pollinators)] <- 0
  counts$total_species <- counts$n_plants + counts$n_pollinators

  # Keep networks meeting the threshold
  nets_keep <- counts$Network_id[counts$total_species >= min_total]
  if (length(nets_keep) == 0) {
    cat(paste("No networks with total_species >=", min_total, "in", bio, "\n"))
    next
  }

  ## ============================
  ## 3) Build species sets per network (plants + pollinators together)
  ## ============================
  # Subset to kept networks
  dat_bio_sub <- dat_bio[dat_bio$Network_id %in% nets_keep, , drop = FALSE]

  # Normalize names (optional but recommended)
  plant_names <- normalize_name(dat_bio_sub$Plant_accepted_name)
  poll_names  <- normalize_name(dat_bio_sub$Pollinator_accepted_name)

  # Tag guilds to avoid accidental collisions
  plant_tags <- paste0("PLANT::", plant_names)
  poll_tags  <- paste0("POLL::",  poll_names)

  # Split row indices by Network_id so we can collect species per network
  idx_by_net <- split(seq_len(nrow(dat_bio_sub)), dat_bio_sub$Network_id)

  # For each network, take the union of unique plant & pollinator tags
  species_items <- lapply(idx_by_net, function(idx) {
    unique(c(plant_tags[idx], poll_tags[idx]))
  })
  # 'species_items' is a named list: names(species_items) are Network_id values

  net_ids <- names(species_items)
  n <- length(net_ids)

  ## ============================
  ## 4) Pairwise Jaccard matrix (upper triangle fill)
  ## ============================
  cat(sprintf("Number of networks for %s: %d\n", bio, n)) # Diagnostic
  sim_mat <- matrix(NA_real_, nrow = n, ncol = n, dimnames = list(net_ids, net_ids))

  for (i in seq_len(n)) {
    # diagonal
    sim_mat[i, i] <- NA_real_
    # upper triangle only
    if (i < n) {
      for (j in (i + 1L):n) {
        val <- jaccard_sets(species_items[[i]], species_items[[j]])
        sim_mat[i, j] <- val
        sim_mat[j, i] <- val
      }
    }
  }

  ## ============================
  ## 5) Tidy table of unique pairs, sorted high-to-low, with Rank
  ## ============================
  # Convert matrix to data.frame of pairs
  # We'll keep only i<j to avoid duplicates
  pairs_list <- list()
  k <- 0L
  for (i in seq_len(n)) {
    if (i < n) {
      for (j in (i + 1L):n) {
        k <- k + 1L
        pairs_list[[k]] <- data.frame(
          Net1 = net_ids[i],
          Net2 = net_ids[j],
          Jaccard = sim_mat[i, j],
          stringsAsFactors = FALSE
        )
      }
    }
  }
  sim_df <- do.call(rbind, pairs_list)
  if (is.null(sim_df) || nrow(sim_df) == 0 || !("Jaccard" %in% names(sim_df)) || all(is.na(sim_df$Jaccard))) {
    cat(sprintf("No valid Jaccard similarities for %s (empty or all NA).\n", bio))
    next
  }

  # Remove NA (shouldn't be any except degenerate cases) and sort descending
  sim_df <- sim_df[!is.na(sim_df$Jaccard), , drop = FALSE]
  ord <- order(sim_df$Jaccard, decreasing = TRUE)
  sim_df <- sim_df[ord, , drop = FALSE]

  # Keep top N pairs (optional)
  if (!is.null(top_n_pairs) && is.finite(top_n_pairs)) {
    top_n <- min(top_n_pairs, nrow(sim_df))
    sim_top <- sim_df[seq_len(top_n), , drop = FALSE]
  } else {
    sim_top <- sim_df
  }

  ## ============================
  ## 6) Inspect results
  ## ============================
  cat(sprintf("\n=== Top similar network pairs for %s ===\n", bio))
  print(head(sim_top, 20), row.names = FALSE)

  ## ============================
  ## 6b) Heatmap of Jaccard similarities
  ## ============================
  # Convert sim_mat to long format for ggplot
  sim_mat_long <- as.data.frame.table(sim_mat, responseName = "Jaccard")
  names(sim_mat_long)[1:2] <- c("Net1", "Net2")
  sim_mat_long <- sim_mat_long[!is.na(sim_mat_long$Jaccard), ]

  # Create heatmap
  p_heatmap <- ggplot(sim_mat_long, aes(x = Net1, y = Net2, fill = Jaccard)) +
    geom_tile() +
    scale_fill_continuous_sequential(palette = "Viridis", name = "Jaccard Similarity") +
    labs(
      title = sprintf("Jaccard Similarity Heatmap for %s", bio),
      x = "Network ID", y = "Network ID"
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 75, hjust = 1, size = 3),
      axis.text.y = element_text(size = 3),
      panel.grid = element_blank()
    )

  print(p_heatmap)

  ## If you want the unique networks appearing in the top pairs:
  unique_nets <- unique(c(sim_top$Net1, sim_top$Net2))

  ## ============================
  ## 7) Collect per-network coordinates for the networks in top pairs
  ## ============================
  # unique networks from the top pairs
  unique_nets <- unique(c(sim_top$Net1, sim_top$Net2))

  # subset interactions to the chosen bioregion and those networks
  dat_map <- dat_bio_sub[dat_bio_sub$Network_id %in% unique_nets, , drop = FALSE]

  # basic sanity
  if (!all(c("Latitude","Longitude") %in% names(dat_map))) {
    cat("Latitude/Longitude columns are missing in the dataset.\n")
    next
  }

  # Ensure numeric (safely)
  dat_map$Latitude  <- suppressWarnings(as.numeric(dat_map$Latitude))
  dat_map$Longitude <- suppressWarnings(as.numeric(dat_map$Longitude))

  # remove rows with missing coordinates
  dat_map <- dat_map[!is.na(dat_map$Latitude) & !is.na(dat_map$Longitude), , drop = FALSE]
  if (nrow(dat_map) == 0) {
    cat("No valid coordinates to plot.\n")
    next
  }

  ## For each Network_id, take a single representative lat/lon (first unique non-NA)
  first_unique <- function(x) {
    ux <- unique(x)
    ux[!is.na(ux)][1]
  }

  # aggregate coordinates per network (base R)
  lat_by_net <- aggregate(Latitude  ~ Network_id, data = dat_map, FUN = first_unique)
  lon_by_net <- aggregate(Longitude ~ Network_id, data = dat_map, FUN = first_unique)

  # merge back
  net_locs <- merge(lat_by_net, lon_by_net, by = "Network_id", all = TRUE)

  # (optional) add total species to size points (we already computed 'counts' earlier)
  net_locs <- merge(net_locs, counts[, c("Network_id","total_species")], by = "Network_id", all.x = TRUE)

  # keep only networks we actually plot
  net_locs <- net_locs[net_locs$Network_id %in% unique_nets, , drop = FALSE]

  ## ============================
  ## 8) Determine map extents with a small buffer
  ## ============================
  lat_range <- range(net_locs$Latitude,  na.rm = TRUE)
  lon_range <- range(net_locs$Longitude, na.rm = TRUE)
  lat_buffer <- 1
  lon_buffer <- 2
  xlim <- c(lon_range[1] - lon_buffer, lon_range[2] + lon_buffer)
  ylim <- c(lat_range[1] - lat_buffer, lat_range[2] + lat_buffer)

  ## ============================
  ## 9) Base map (Europe) and plot
  ## ============================
  europe <- rnaturalearth::ne_countries(scale = "medium", returnclass = "sf", continent = "Europe")

  # simple palette for distinct networks
  n_cols <- length(unique(net_locs$Network_id))
  cols <- grDevices::hcl.colors(n_cols, palette = "Spectral", rev = TRUE)

  p_map <- ggplot(europe) +
    geom_sf(fill = "beige", color = "black", linewidth = 0.2) +
    geom_point(
      data = net_locs,
      aes(x = Longitude, y = Latitude, color = Network_id, size = total_species),
      alpha = 0.8
    ) +
    scale_color_manual(values = cols, guide = "none") +
    scale_size_continuous(range = c(2, 8), name = "Total Species") +
    # IMPORTANT for newer ggplot2: allow numeric xlim/ylim on lon/lat
    coord_sf(xlim = xlim, ylim = ylim, expand = FALSE, default_crs = NULL) +
    labs(
      title = sprintf("Top similar networks in %s (species-based Jaccard)", bio),
      subtitle = sprintf("Points sized by total species; Lat range: %.2f–%.2f",
                         lat_range[1], lat_range[2]),
      x = "Longitude", y = "Latitude", color = "Network_id"
    ) +
    theme_minimal() +
    theme(legend.position = "bottom")

  print(p_map)
}
```

```{r}
# ============================
# Extended EDA Pipeline for Top Jaccard Pairs in Continental Bioregion
# ============================
# This pipeline expands on the previous by adding more comparisons between all selected networks:
# 1. Pairwise comparisons: Expanded shared species analysis, Jaccard heatmap for top networks.
# 2. Species composition: Presence/absence matrix, PCA for species across networks, top species per network.
# 3. Interaction patterns: Degree distributions for plants and pollinators, compared across networks.
# 4. Network structure: Additional metrics (e.g., nestedness, modularity using bipartite).
# 5. Visualizations: Boxplots for metrics, biplots for PCA, etc.

# Note: Assumes Interaction_data.csv has columns: Bioregion, Network_id, Plant_accepted_name, Pollinator_accepted_name, Interaction (for degrees), Latitude, Longitude.
# Install additional packages if needed: install.packages(c("bipartite", "igraph", "vegan")) for modularity and PCA.

library(dplyr)
library(readr)
library(ggplot2)
library(rnaturalearth)
library(rnaturalearthdata)
library(sf)
library(tidyr)
library(purrr)
library(bipartite)  # For network metrics like connectance, nestedness, modularity
library(igraph)    # For graph analysis
library(vegan)     # For PCA (rda for presence/absence)

setwd("/Users/shirn/OneDrive/Documents/master/data")

# Parameters (easy to tweak)
bio <- "Continental"  # Focus on this bioregion
min_total <- 15       # Minimum total species per network
top_n_pairs <- 100     # Focus on top 10 pairs with highest Jaccard (adjust as needed)

# ============================
# Read data
# ============================
interactions <- read.csv("Interaction_data.csv", stringsAsFactors = FALSE)

# ============================
# Utilities
# ============================
normalize_name <- function(x) {
  x <- trimws(x)
  x <- gsub("\\s+", " ", x)
  tolower(x)
}

jaccard_sets <- function(a, b) {
  a <- unique(a); b <- unique(b)
  ia <- length(intersect(a, b))
  ua <- length(union(a, b))
  if (ua == 0) NA_real_ else ia / ua
}

# ============================
# Basic column checks
# ============================
req_cols <- c("Bioregion", "Network_id", "Plant_accepted_name", "Pollinator_accepted_name")
missing_cols <- setdiff(req_cols, names(interactions))
if (length(missing_cols) > 0) {
  stop(paste("Missing required columns:", paste(missing_cols, collapse = ", ")))
}

# ============================
# 1) Filter to Continental bioregion
# ============================
dat_bio <- interactions[interactions$Bioregion == bio, , drop = FALSE]

if (nrow(dat_bio) == 0) {
  stop(paste("No rows for Bioregion:", bio))
}

# ============================
# 2) Compute species counts per network
# ============================
plants_by_net <- aggregate(Plant_accepted_name ~ Network_id, data = dat_bio,
                           FUN = function(x) length(unique(x)))
names(plants_by_net)[2] <- "n_plants"

polls_by_net <- aggregate(Pollinator_accepted_name ~ Network_id, data = dat_bio,
                          FUN = function(x) length(unique(x)))
names(polls_by_net)[2] <- "n_pollinators"

counts <- merge(plants_by_net, polls_by_net, by = "Network_id", all = TRUE)
counts$n_plants[is.na(counts$n_plants)] <- 0
counts$n_pollinators[is.na(counts$n_pollinators)] <- 0
counts$total_species <- counts$n_plants + counts$n_pollinators

nets_keep <- counts$Network_id[counts$total_species >= min_total]
if (length(nets_keep) == 0) {
  stop(paste("No networks with total_species >=", min_total, "in", bio))
}

# ============================
# 3) Build species sets per network
# ============================
dat_bio_sub <- dat_bio[dat_bio$Network_id %in% nets_keep, , drop = FALSE]

plant_names <- normalize_name(dat_bio_sub$Plant_accepted_name)
poll_names  <- normalize_name(dat_bio_sub$Pollinator_accepted_name)

plant_tags <- paste0("PLANT::", plant_names)
poll_tags  <- paste0("POLL::", poll_names)

idx_by_net <- split(seq_len(nrow(dat_bio_sub)), dat_bio_sub$Network_id)

species_items <- lapply(idx_by_net, function(idx) {
  unique(c(plant_tags[idx], poll_tags[idx]))
})

net_ids <- names(species_items)
n <- length(net_ids)

# ============================
# 4) Pairwise Jaccard matrix
# ============================
sim_mat <- matrix(NA_real_, nrow = n, ncol = n, dimnames = list(net_ids, net_ids))

for (i in seq_len(n)) {
  sim_mat[i, i] <- NA_real_
  if (i < n) {
    for (j in (i + 1L):n) {
      val <- jaccard_sets(species_items[[i]], species_items[[j]])
      sim_mat[i, j] <- val
      sim_mat[j, i] <- val
    }
  }
}

# ============================
# 5) Tidy table of unique pairs, sorted high-to-low
# ============================
pairs_list <- list()
k <- 0L
for (i in seq_len(n)) {
  if (i < n) {
    for (j in (i + 1L):n) {
      k <- k + 1L
      pairs_list[[k]] <- data.frame(
        Net1 = net_ids[i],
        Net2 = net_ids[j],
        Jaccard = sim_mat[i, j],
        stringsAsFactors = FALSE
      )
    }
  }
}
sim_df <- do.call(rbind, pairs_list)

if (is.null(sim_df) || nrow(sim_df) == 0 || !("Jaccard" %in% names(sim_df)) || all(is.na(sim_df$Jaccard))) {
  stop(sprintf("No valid Jaccard similarities for %s (empty or all NA).", bio))
}

sim_df <- sim_df[!is.na(sim_df$Jaccard), , drop = FALSE]
ord <- order(sim_df$Jaccard, decreasing = TRUE)
sim_df <- sim_df[ord, , drop = FALSE]

top_n <- min(top_n_pairs, nrow(sim_df))
sim_top <- sim_df[seq_len(top_n), , drop = FALSE]

# ============================
# 6) Inspect top pairs
# ============================
cat(sprintf("\n=== Top %d similar network pairs in %s ===\n", top_n, bio))
print(sim_top, row.names = FALSE)

# Collect unique networks from top pairs
unique_nets <- unique(c(sim_top$Net1, sim_top$Net2))

# ============================
# EDA Pipeline on Top Networks
# ============================
# Subset data to top networks
top_data <- dat_bio_sub[dat_bio_sub$Network_id %in% unique_nets, , drop = FALSE]

# 6a) Summary Statistics
# - Species richness per network
species_summary <- counts[counts$Network_id %in% unique_nets, ]
cat("\n=== Species Richness Summary for Top Networks ===\n")
print(species_summary)

# - Pairwise shared species (expanded)
shared_species <- data.frame()
for (i in seq_len(nrow(sim_top))) {
  net1 <- sim_top$Net1[i]
  net2 <- sim_top$Net2[i]
  sp1 <- species_items[[net1]]
  sp2 <- species_items[[net2]]
  shared_plants <- length(intersect(sp1[grep("^PLANT::", sp1)], sp2[grep("^PLANT::", sp2)]))
  shared_polls <- length(intersect(sp1[grep("^POLL::", sp1)], sp2[grep("^POLL::", sp2)]))
  shared_species <- rbind(shared_species, data.frame(Net1 = net1, Net2 = net2, Shared_Plants = shared_plants, Shared_Polls = shared_polls, Jaccard = sim_top$Jaccard[i]))
}
cat("\n=== Shared Species (Plants and Pollinators) for Top Pairs ===\n")
print(shared_species)

# - Interaction counts (assuming 'Interaction' column exists for frequency; adjust if named differently)
if ("Interaction" %in% names(top_data)) {
  interaction_summary <- aggregate(Interaction ~ Network_id, data = top_data, FUN = sum)
  names(interaction_summary)[2] <- "Total_Interactions"
  cat("\n=== Interaction Counts for Top Networks ===\n")
  print(interaction_summary)
} else {
  cat("\nNote: No 'Interaction' column found; skipping interaction counts.\n")
}

# - Top common species across all top networks
all_species <- unlist(species_items[unique_nets])
species_freq <- table(all_species)
top_species <- head(sort(species_freq, decreasing = TRUE), 10)
cat("\n=== Top 10 Common Species Across Top Networks ===\n")
print(top_species)

# 6b) Visualizations
# - Histogram of species richness
p_richness <- ggplot(species_summary, aes(x = total_species)) +
  geom_histogram(binwidth = 5, fill = "blue", color = "black") +
  labs(title = "Distribution of Total Species in Top Networks", x = "Total Species", y = "Count") +
  theme_minimal()
print(p_richness)

# - Bar plot of shared species for top pairs (expanded with plants/polls)
shared_long <- pivot_longer(shared_species, cols = c(Shared_Plants, Shared_Polls), names_to = "Type", values_to = "Shared")
p_shared <- ggplot(shared_long, aes(x = paste(Net1, Net2, sep = "-"), y = Shared, fill = Type)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Shared Species in Top Jaccard Pairs", x = "Network Pair", y = "Shared Species") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(p_shared)

# - Interaction heatmap for the top pair (example for highest Jaccard)
top_pair <- sim_top[1, c("Net1", "Net2")]
pair_data <- top_data[top_data$Network_id %in% c(top_pair$Net1, top_pair$Net2), ]
p_interaction <- ggplot(pair_data, aes(x = Plant_accepted_name, y = Pollinator_accepted_name, fill = Interaction)) +
  geom_tile(color = "white", size = 0.01) +
  scale_fill_continuous_sequential(palette = "Viridis", na.value = "white") +
  facet_wrap(~ Network_id) +  # Facet by network for comparison
  labs(title = sprintf("Interaction Heatmap for Top Pair: %s - %s", top_pair$Net1, top_pair$Net2),
       x = "Plants", y = "Pollinators") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
print(p_interaction)

# - Degree distribution comparison (plant and pollinator degrees across networks)
if ("Interaction" %in% names(top_data)) {
  # Compute degrees
  plant_degree <- top_data %>%
    group_by(Network_id, Plant_accepted_name) %>%
    summarise(Degree = sum(Interaction > 0), .groups = "drop")
  poll_degree <- top_data %>%
    group_by(Network_id, Pollinator_accepted_name) %>%
    summarise(Degree = sum(Interaction > 0), .groups = "drop")

  # Boxplot comparison
  p_plant_degree <- ggplot(plant_degree, aes(x = Network_id, y = Degree)) +
    geom_boxplot(fill = "lightblue") +
    labs(title = "Plant Degree Distribution Across Top Networks", x = "Network ID", y = "Degree") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  print(p_plant_degree)

  p_poll_degree <- ggplot(poll_degree, aes(x = Network_id, y = Degree)) +
    geom_boxplot(fill = "lightgreen") +
    labs(title = "Pollinator Degree Distribution Across Top Networks", x = "Network ID", y = "Degree") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  print(p_poll_degree)
} else {
  cat("\nNote: No 'Interaction' column found; skipping degree distributions.\n")
}

# 6c) Species Composition Analysis
# - Build presence/absence matrix for all species across top networks
all_unique_species <- unique(unlist(species_items[unique_nets]))
presence_matrix <- matrix(0, nrow = length(unique_nets), ncol = length(all_unique_species),
                          dimnames = list(unique_nets, all_unique_species))

for (net in unique_nets) {
  presence_matrix[net, species_items[[net]]] <- 1
}

# - PCA on presence/absence matrix
pca_result <- rda(presence_matrix ~ 1)  # Unconstrained PCA
pca_scores <- scores(pca_result, choices = 1:2, display = "sites")

pca_df <- data.frame(Network_id = rownames(pca_scores), PC1 = pca_scores[,1], PC2 = pca_scores[,2])

p_pca <- ggplot(pca_df, aes(x = PC1, y = PC2, label = Network_id)) +
  geom_point(size = 3, color = "red") +
  geom_text(vjust = -1) +
  labs(title = "PCA of Species Composition Across Top Networks", x = "PC1", y = "PC2") +
  theme_minimal()
print(p_pca)

# - Top species per network
top_species_per_net <- list()
for (net in unique_nets) {
  net_data <- top_data[top_data$Network_id == net, ]
  plant_freq <- table(net_data$Plant_accepted_name)
  poll_freq <- table(net_data$Pollinator_accepted_name)
  top_plants <- head(sort(plant_freq, decreasing = TRUE), 5)
  top_polls <- head(sort(poll_freq, decreasing = TRUE), 5)
  cat(sprintf("\n=== Top 5 Plants in Network %s ===\n", net))
  print(top_plants)
  cat(sprintf("\n=== Top 5 Pollinators in Network %s ===\n", net))
  print(top_polls)
}

# 6d) Network Metrics (expanded)
# For each top network, compute connectance, nestedness, modularity
network_metrics <- data.frame(Network_id = unique_nets, Connectance = NA, Nestedness = NA, Modularity = NA)
for (net in unique_nets) {
  net_data <- top_data[top_data$Network_id == net, ]
  if ("Interaction" %in% names(net_data)) {
    bip_matrix <- table(net_data$Plant_accepted_name, net_data$Pollinator_accepted_name)
    network_metrics$Connectance[network_metrics$Network_id == net] <- networklevel(bip_matrix, index = "connectance")
    network_metrics$Nestedness[network_metrics$Network_id == net] <- networklevel(bip_matrix, index = "weighted NODF")
    mod <- computeModules(bip_matrix)
    network_metrics$Modularity[network_metrics$Network_id == net] <- mod@likelihood
  }
}
cat("\n=== Expanded Network Metrics for Top Networks ===\n")
print(network_metrics)

# - Visualization: Boxplots for metrics across networks
metrics_long <- pivot_longer(network_metrics, cols = c(Connectance, Nestedness, Modularity), names_to = "Metric", values_to = "Value")
p_metrics <- ggplot(metrics_long, aes(x = Metric, y = Value)) +
  geom_boxplot(fill = "orange") +
  labs(title = "Network Metrics Distribution in Top Networks", y = "Value") +
  theme_minimal()
print(p_metrics)

# 6e) Spatial Analysis (Map of top networks)
net_locs <- aggregate(cbind(Latitude, Longitude) ~ Network_id, data = top_data, FUN = mean, na.rm = TRUE)
net_locs <- merge(net_locs, species_summary[, c("Network_id", "total_species")], by = "Network_id")

europe <- ne_countries(scale = "medium", returnclass = "sf", continent = "Europe")

lat_range <- range(net_locs$Latitude, na.rm = TRUE)
lon_range <- range(net_locs$Longitude, na.rm = TRUE)
lat_buffer <- 1; lon_buffer <- 2
xlim <- c(lon_range[1] - lon_buffer, lon_range[2] + lon_buffer)
ylim <- c(lat_range[1] - lat_buffer, lat_range[2] + lat_buffer)

cols <- grDevices::hcl.colors(nrow(net_locs), "Spectral", rev = TRUE)

p_map <- ggplot(europe) +
  geom_sf(fill = "beige", color = "black", linewidth = 0.2) +
  geom_point(
    data = net_locs,
    aes(x = Longitude, y = Latitude, color = Network_id, size = total_species),
    alpha = 0.8
  ) +
  scale_color_manual(values = cols, guide = "none") +
  scale_size_continuous(range = c(2, 8), name = "Total Species") +
  coord_sf(xlim = xlim, ylim = ylim, expand = FALSE) +
  labs(
    title = sprintf("Top Similar Networks in %s", bio),
    subtitle = sprintf("Points sized by total species; Lat range: %.2f–%.2f", lat_range[1], lat_range[2]),
    x = "Longitude", y = "Latitude"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")
print(p_map)

# Optional: Save outputs
# ggsave("continental_top_richness_hist.png", p_richness)
# ggsave("continental_top_shared_bar.png", p_shared)
# ggsave("continental_top_interaction_heatmap.png", p_interaction)
# ggsave("continental_plant_degree_box.png", p_plant_degree)
# ggsave("continental_poll_degree_box.png", p_poll_degree)
# ggsave("continental_species_pca.png", p_pca)
# ggsave("continental_network_metrics_box.png", p_metrics)
# ggsave("continental_top_map.png", p_map)

# End of Extended EDA Pipeline

```

